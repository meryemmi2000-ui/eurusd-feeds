name: THANOS (EURUSD M5 every 15m)

permissions:
  contents: write

on:
  schedule:
    - cron: "*/15 * * * *"   # toutes les 15 minutes
  workflow_dispatch: {}

jobs:
  thanos:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { persist-credentials: true }

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install pandas requests

      # (optionnel) on tente de récupérer le pepperstone.csv du repo (s'il existe)
      - name: Fetch optional Pepperstone raw from repo
        run: |
          mkdir -p data
          curl -L --fail -A "Mozilla/5.0" \
            "https://raw.githubusercontent.com/meryemmi2000-ui/eurusd-feeds/refs/heads/main/data/pepperstone.csv" \
            -o data/pepperstone.csv || true

      - name: Run THANOS (fetch, analyze, export + alert flag)
        env:
          TD_API_KEY: ${{ secrets.TD_API_KEY }}
        run: |
          python - <<'PY'
          import os, io, re, json, sys
          import pandas as pd
          import requests
          from pathlib import Path
          from datetime import datetime, timezone

          outdir = Path('data'); outdir.mkdir(exist_ok=True)
          log = []

          def normalize_ohlc(df, source):
            try:
              cols = {c.lower(): c for c in df.columns}
              dt = cols.get('datetime') or cols.get('time') or cols.get('date')
              o  = cols.get('open'); h = cols.get('high'); l = cols.get('low'); c = cols.get('close')
              if not (dt and o and h and l and c): return None
              _df = pd.DataFrame({
                'datetime': pd.to_datetime(df[dt], errors='coerce'),
                'open':  pd.to_numeric(df[o], errors='coerce'),
                'high':  pd.to_numeric(df[h], errors='coerce'),
                'low':   pd.to_numeric(df[l], errors='coerce'),
                'close': pd.to_numeric(df[c], errors='coerce'),
              }).dropna().sort_values('datetime')
              if _df.empty: return None
              _df['datetime'] = _df['datetime'].dt.floor('5min')
              _df = _df.drop_duplicates('datetime')
              _df['source'] = source
              return _df
            except Exception:
              return None

          def fetch_twelvedata_api(key):
            if not key:
              log.append('TD_API_KEY manquant.')
              return None
            url = f"https://api.twelvedata.com/time_series?symbol=EUR/USD&interval=5min&outputsize=600&format=CSV&apikey={key}"
            try:
              r = requests.get(url, headers={'User-Agent':'Mozilla/5.0'}, timeout=30)
              Path('data/td_status.txt').write_text(f"{r.status_code}\n{r.text[:300]}", encoding='utf-8')
              txt = r.text.strip()
              if r.status_code == 200 and txt.lower().startswith('datetime,'):
                df = pd.read_csv(io.StringIO(txt))
                return normalize_ohlc(df, 'twelvedata_api')
              log.append(f"TD API contenu inattendu (status {r.status_code}).")
              return None
            except Exception as e:
              log.append(f"TD API erreur: {e}")
              return None

          def fetch_raw_csv(url, sep, source):
            try:
              df = pd.read_csv(url, sep=sep)
              return normalize_ohlc(df, source)
            except Exception as e:
              log.append(f"Echec RAW {source}: {e}")
              return None

          def fetch_pepperstone_local():
            p = Path('data/pepperstone.csv')
            if not p.exists(): return None
            # Essai CSV direct
            try:
              df = pd.read_csv(p, sep=None, engine='python')
              n = normalize_ohlc(df, 'pepperstone_raw')
              if n is not None: return n
            except Exception:
              pass
            # Fallback regex (lignes type "YYYY.MM.DD HH:MM O H L C …")
            try:
              rx = re.compile(r'(\d{4}\.\d{2}\.\d{2})\s+(\d{2}:\d{2})(?::\d{2})?\s+([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)')
              rows=[]
              for ln in p.read_text(encoding='utf-8', errors='ignore').splitlines():
                m = rx.search(ln)
                if m:
                  d,t,o,h,l,c = m.groups()
                  ts = pd.to_datetime(d.replace('.','-')+' '+t+':00', errors='coerce')
                  rows.append((ts,float(o),float(h),float(l),float(c)))
              if rows:
                df = pd.DataFrame(rows, columns=['datetime','open','high','low','close'])
                df = df.dropna().sort_values('datetime')
                df['datetime'] = df['datetime'].dt.floor('5min')
                df = df.drop_duplicates('datetime')
                df['source'] = 'pepperstone_raw'
                return df
              return None
            except Exception as e:
              log.append(f"Pepperstone regex erreur: {e}")
              return None

          key = os.environ.get('TD_API_KEY')

          # 1) Source principale: TwelveData API
          td = fetch_twelvedata_api(key)
          # 2) Fallback repo: TwelveData CSV publié (séparateur ';')
          if td is None:
            td = fetch_raw_csv(
              'https://raw.githubusercontent.com/meryemmi2000-ui/eurusd-feeds/refs/heads/main/data/twelvedata.csv',
              sep=';',
              source='twelvedata_repo'
            )
          # 3) Pepperstone local (si téléchargé)
          ps = fetch_pepperstone_local()

          sources = [x for x in [td, ps] if x is not None and not x.empty]
          if not sources:
            Path('data/thanos_summary.md').write_text(
              "## THANOS\nAucune donnée disponible.\n"
              "- Vérifie le secret **TD_API_KEY** (Settings → Secrets)\n"
              "- Ou le fichier `data/twelvedata.csv` dans le repo\n",
              encoding='utf-8'
            )
            Path('data/thanos_flag.txt').write_text("", encoding='utf-8')
            Path('data/last_updated.txt').write_text(datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC'), encoding='utf-8')
            sys.exit(0)

          # Choisit la source la plus récente
          best = max(sources, key=lambda d: d['datetime'].max())

          # Indicateurs & règles
          pip = 0.0001; thr = 3*pip
          df = best.copy()
          df['rollH20'] = df['high'].rolling(20, min_periods=20).max().shift(1)
          df['rollL20'] = df['low'].rolling(20, min_periods=20).min().shift(1)
          df['up2'] = (df['close'] > (df['rollH20'] + thr)) & (df['close'].shift(1) > (df['rollH20'].shift(1) + thr))
          df['dn2'] = (df['close'] < (df['rollL20'] - thr)) & (df['close'].shift(1) < (df['rollL20'].shift(1) - thr))

          # Exports
          df[['datetime','open','high','low','close']].to_csv('data/thanos_ready.csv', index=False)

          last = df.iloc[-1]
          lines = [
            "# THANOS — EURUSD M5 (auto/15m)",
            f"Dernière bougie: {last['datetime']:%Y-%m-%d %H:%M:%S}  O={last['open']:.5f}  H={last['high']:.5f}  L={last['low']:.5f}  C={last['close']:.5f}",
            f"Source active: {best['source'].iloc[0]}",
            ""
          ]
          flag = ""
          if bool(last['up2']):
            lines.append("- ✅ **UP**: 2 clôtures > plus haut 20 bougies (+3 pips)."); flag = "ALERT"
          if bool(last['dn2']):
            lines.append("- ✅ **DOWN**: 2 clôtures < plus bas 20 bougies (−3 pips)."); flag = "ALERT"
          if flag == "":
            lines.append("- Aucun signal sur la dernière bougie.")

          if log:
            lines.append("\n<details><summary>Debug</summary>\n\n" + "\n".join(f"- {m}" for m in log) + "\n\n</details>")

          Path('data/thanos_summary.md').write_text("\n".join(lines), encoding='utf-8')
          df.tail(12).to_csv('data/thanos_evidence.md', index=False)

          state = {
            "datetime": str(last['datetime']),
            "open": round(float(last['open']),5),
            "high": round(float(last['high']),5),
            "low":  round(float(last['low']),5),
            "close":round(float(last['close']),5),
            "rollH20": None if pd.isna(last['rollH20']) else round(float(last['rollH20']),5),
            "rollL20": None if pd.isna(last['rollL20']) else round(float(last['rollL20']),5),
            "up2": bool(last['up2']),
            "dn2": bool(last['dn2']),
            "source": best['source'].iloc[0]
          }
          Path('data/thanos_state.json').write_text(json.dumps(state, indent=2), encoding='utf-8')
          Path('data/thanos_flag.txt').write_text(flag, encoding='utf-8')
          Path('data/last_updated.txt').write_text(datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC'), encoding='utf-8')
          PY

      - name: Commit results
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add data/*
          git commit -m "THANOS outputs" || echo "No changes"
          git push
